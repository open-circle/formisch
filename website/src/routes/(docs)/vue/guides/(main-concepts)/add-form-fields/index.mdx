---
title: Add form fields
description: >-
  Learn how to add fields to your form using the Field component or useField
  composable. Both are headless and provide access to field state for building
  your form UI.
contributors:
  - fabian-hiller
---

import { Link } from '~/components';

# Add form fields

To add a field to your form, you can use the <Link href="/vue/api/Field/">`Field`</Link> component or the <Link href="/vue/api/useField/">`useField`</Link> composable. Both are headless and provide access to field state for building your form UI.

## Field component

The <Link href="/vue/api/Field/">`Field`</Link> component has two mandatory properties: `of` which accepts the form store, and `path` which specifies which field to connect. If you use TypeScript, you get full autocompletion for the path based on your schema.

### v-slot directive

As a child, you use the `v-slot` directive to access the field store, which includes the current value, error messages, and props to spread onto your input element.

```vue
<script setup lang="ts">
import { Field, Form, useForm } from '@formisch/vue';
import * as v from 'valibot';

const LoginSchema = v.object({
  email: v.pipe(v.string(), v.email()),
  password: v.pipe(v.string(), v.minLength(8)),
});

const loginForm = useForm({
  schema: LoginSchema,
});
</script>

<template>
  <Form :of="loginForm">
    <Field :of="loginForm" :path="['email']" v-slot="field">
      <input v-model="field.input" v-bind="field.props" type="email" />
    </Field>
    <Field :of="loginForm" :path="['password']" v-slot="field">
      <input v-model="field.input" v-bind="field.props" type="password" />
    </Field>
    <button type="submit">Login</button>
  </Form>
</template>
```

> **Important:** If you plan to set initial values with `initialInput` or programmatically control field values using methods like <Link href="/methods/api/setInput/">`setInput`</Link> or <Link href="/methods/api/reset/">`reset`</Link>, you must make your fields controlled by setting the appropriate attributes (like `v-model`, `checked`, or `selected`). See the <Link href="/vue/guides/controlled-fields/">controlled fields</Link> guide to learn more.

### Headless design

The <Link href="/vue/api/Field/">`Field`</Link> component does not render its own UI elements. It is headless and provides only the data layer of the field. This allows you to freely define your user interface. You can use HTML elements, custom components or an external UI library.

### Path array

The `path` property accepts an array of strings and numbers that represents the path to the field in your schema. For top-level fields, it's simply the field name wrapped in an array:

```vue
<Field :of="loginForm" :path="['email']" v-slot="field">
  <input v-model="field.input" v-bind="field.props" type="email" />
</Field>
```

For nested fields, the path reflects the structure of your schema:

```vue
<!-- For a schema like: v.object({ user: v.object({ email: v.string() }) }) -->
<Field :of="form" :path="['user', 'email']" v-slot="field">
  <input v-model="field.input" v-bind="field.props" type="email" />
</Field>
```

### Type safety

The API design of the <Link href="/vue/api/Field/">`Field`</Link> component results in a fully type-safe form. For example, if you change your schema, TypeScript will immediately alert you if the path is invalid. The field state is also fully typed based on your schema, giving you autocompletion for properties like `field.input`.

## useField composable

For very complex forms where you create individual components for each form field, Formisch provides the <Link href="/vue/api/useField/">`useField`</Link> composable. It allows you to access the field state directly within your component logic.

```vue
<script setup lang="ts">
import { useField } from '@formisch/vue';
import type { FormStore } from '@formisch/vue';
import * as v from 'valibot';

type EmailInputProps = {
  form: FormStore<v.GenericSchema<{ email: string }>>;
};

const props = defineProps<EmailInputProps>();

const field = useField(
  () => props.form,
  () => ({ path: ['email'] })
);
</script>

<template>
  <div>
    <input v-model="field.input" v-bind="field.props" type="email" />
    <div v-if="field.errors">{{ field.errors[0] }}</div>
  </div>
</template>
```

### When to use which

- **Use `Field` component**: When defining multiple fields in the same component. It ensures you don't accidentally access the wrong field store.
- **Use `useField` composable**: When creating field components for single fields. It allows you to access field state in your component logic.

The <Link href="/vue/api/Field/">`Field`</Link> component is essentially a thin wrapper around <Link href="/vue/api/useField/">`useField`</Link> that allows you to access the field state within template code.

## Field store

The field store provides access to the following properties:

- `props`: JSX props to spread onto your input element (includes event handlers, ref callback, name attribute, and `autofocus` to automatically focus fields with errors).
- `input`: The current input value of the field.
- `errors`: An array of error messages if validation fails.
- `isTouched`: Whether the field has been touched.
- `isDirty`: Whether the current input differs from the initial input.
- `isValid`: Whether the field passes all validation rules.

## Next steps

Now that you know how to add fields to your form, continue to the <Link href="/vue/guides/input-components/">input components</Link> guide to learn about creating reusable input components for your forms.
